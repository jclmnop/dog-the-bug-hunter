// This file is @generated by wasmcloud/weld-codegen 0.7.0.
// It is not intended for manual editing.
// namespace: jclmnop.dtbh.interface.common

#[allow(unused_imports)]
use async_trait::async_trait;
#[allow(unused_imports)]
use serde::{Deserialize, Serialize};
#[allow(unused_imports)]
use std::{borrow::Borrow, borrow::Cow, io::Write, string::ToString};
#[allow(unused_imports)]
use wasmbus_rpc::{
    cbor::*,
    common::{
        deserialize, message_format, serialize, Context, Message,
        MessageDispatch, MessageFormat, SendOpts, Transport,
    },
    error::{RpcError, RpcResult},
    Timestamp,
};

#[allow(dead_code)]
pub const SMITHY_VERSION: &str = "1.0";

#[derive(Clone, Debug, Default, Deserialize, Eq, PartialEq, Serialize)]
pub struct Finding {
    #[serde(rename = "findingType")]
    #[serde(default)]
    pub finding_type: String,
    #[serde(default)]
    pub url: String,
}

// Encode Finding as CBOR and append to output stream
#[doc(hidden)]
#[allow(unused_mut)]
pub fn encode_finding<W: wasmbus_rpc::cbor::Write>(
    mut e: &mut wasmbus_rpc::cbor::Encoder<W>,
    val: &Finding,
) -> RpcResult<()>
where
    <W as wasmbus_rpc::cbor::Write>::Error: std::fmt::Display,
{
    e.map(2)?;
    e.str("findingType")?;
    e.str(&val.finding_type)?;
    e.str("url")?;
    e.str(&val.url)?;
    Ok(())
}

// Decode Finding from cbor input stream
#[doc(hidden)]
pub fn decode_finding(
    d: &mut wasmbus_rpc::cbor::Decoder<'_>,
) -> Result<Finding, RpcError> {
    let __result = {
        let mut finding_type: Option<String> = None;
        let mut url: Option<String> = None;

        let is_array = match d.datatype()? {
            wasmbus_rpc::cbor::Type::Array => true,
            wasmbus_rpc::cbor::Type::Map => false,
            _ => {
                return Err(RpcError::Deser(
                    "decoding struct Finding, expected array or map"
                        .to_string(),
                ))
            }
        };
        if is_array {
            let len = d.fixed_array()?;
            for __i in 0..(len as usize) {
                match __i {
                    0 => finding_type = Some(d.str()?.to_string()),
                    1 => url = Some(d.str()?.to_string()),
                    _ => d.skip()?,
                }
            }
        } else {
            let len = d.fixed_map()?;
            for __i in 0..(len as usize) {
                match d.str()? {
                    "findingType" => finding_type = Some(d.str()?.to_string()),
                    "url" => url = Some(d.str()?.to_string()),
                    _ => d.skip()?,
                }
            }
        }
        Finding {
            finding_type: if let Some(__x) = finding_type {
                __x
            } else {
                return Err(RpcError::Deser(
                    "missing field Finding.finding_type (#0)".to_string(),
                ));
            },

            url: if let Some(__x) = url {
                __x
            } else {
                return Err(RpcError::Deser(
                    "missing field Finding.url (#1)".to_string(),
                ));
            },
        }
    };
    Ok(__result)
}
pub type Findings = Vec<Finding>;

// Encode Findings as CBOR and append to output stream
#[doc(hidden)]
#[allow(unused_mut)]
pub fn encode_findings<W: wasmbus_rpc::cbor::Write>(
    mut e: &mut wasmbus_rpc::cbor::Encoder<W>,
    val: &Findings,
) -> RpcResult<()>
where
    <W as wasmbus_rpc::cbor::Write>::Error: std::fmt::Display,
{
    e.array(val.len() as u64)?;
    for item in val.iter() {
        encode_finding(e, item)?;
    }
    Ok(())
}

// Decode Findings from cbor input stream
#[doc(hidden)]
pub fn decode_findings(
    d: &mut wasmbus_rpc::cbor::Decoder<'_>,
) -> Result<Findings, RpcError> {
    let __result = {
        if let Some(n) = d.array()? {
            let mut arr: Vec<Finding> = Vec::with_capacity(n as usize);
            for _ in 0..(n as usize) {
                arr.push(decode_finding(d).map_err(|e| {
                    format!(
                        "decoding 'jclmnop.dtbh.interface.common#Finding': {}",
                        e
                    )
                })?)
            }
            arr
        } else {
            // indefinite array
            let mut arr: Vec<Finding> = Vec::new();
            loop {
                match d.datatype() {
                                Err(_) => break,
                                Ok(wasmbus_rpc::cbor::Type::Break) => break,
                                Ok(_) => arr.push(decode_finding(d).map_err(|e| format!("decoding 'jclmnop.dtbh.interface.common#Finding': {}", e))?)
                            }
            }
            arr
        }
    };
    Ok(__result)
}
#[derive(Clone, Debug, Default, Deserialize, Eq, PartialEq, Serialize)]
pub struct Port {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub findings: Option<Findings>,
    #[serde(rename = "isOpen")]
    #[serde(default)]
    pub is_open: bool,
    #[serde(default)]
    pub port: u16,
}

// Encode Port as CBOR and append to output stream
#[doc(hidden)]
#[allow(unused_mut)]
pub fn encode_port<W: wasmbus_rpc::cbor::Write>(
    mut e: &mut wasmbus_rpc::cbor::Encoder<W>,
    val: &Port,
) -> RpcResult<()>
where
    <W as wasmbus_rpc::cbor::Write>::Error: std::fmt::Display,
{
    e.map(3)?;
    if let Some(val) = val.findings.as_ref() {
        e.str("findings")?;
        encode_findings(e, val)?;
    } else {
        e.null()?;
    }
    e.str("isOpen")?;
    e.bool(val.is_open)?;
    e.str("port")?;
    e.u16(val.port)?;
    Ok(())
}

// Decode Port from cbor input stream
#[doc(hidden)]
pub fn decode_port(
    d: &mut wasmbus_rpc::cbor::Decoder<'_>,
) -> Result<Port, RpcError> {
    let __result = {
        let mut findings: Option<Option<Findings>> = Some(None);
        let mut is_open: Option<bool> = None;
        let mut port: Option<u16> = None;

        let is_array = match d.datatype()? {
            wasmbus_rpc::cbor::Type::Array => true,
            wasmbus_rpc::cbor::Type::Map => false,
            _ => {
                return Err(RpcError::Deser(
                    "decoding struct Port, expected array or map".to_string(),
                ))
            }
        };
        if is_array {
            let len = d.fixed_array()?;
            for __i in 0..(len as usize) {
                match __i {
                    0 => {
                        findings = if wasmbus_rpc::cbor::Type::Null
                            == d.datatype()?
                        {
                            d.skip()?;
                            Some(None)
                        } else {
                            Some(Some( decode_findings(d).map_err(|e| format!("decoding 'jclmnop.dtbh.interface.common#Findings': {}", e))? ))
                        }
                    }
                    1 => is_open = Some(d.bool()?),
                    2 => port = Some(d.u16()?),
                    _ => d.skip()?,
                }
            }
        } else {
            let len = d.fixed_map()?;
            for __i in 0..(len as usize) {
                match d.str()? {
                    "findings" => {
                        findings = if wasmbus_rpc::cbor::Type::Null
                            == d.datatype()?
                        {
                            d.skip()?;
                            Some(None)
                        } else {
                            Some(Some( decode_findings(d).map_err(|e| format!("decoding 'jclmnop.dtbh.interface.common#Findings': {}", e))? ))
                        }
                    }
                    "isOpen" => is_open = Some(d.bool()?),
                    "port" => port = Some(d.u16()?),
                    _ => d.skip()?,
                }
            }
        }
        Port {
            findings: findings.unwrap(),

            is_open: if let Some(__x) = is_open {
                __x
            } else {
                return Err(RpcError::Deser(
                    "missing field Port.is_open (#1)".to_string(),
                ));
            },

            port: if let Some(__x) = port {
                __x
            } else {
                return Err(RpcError::Deser(
                    "missing field Port.port (#2)".to_string(),
                ));
            },
        }
    };
    Ok(__result)
}
pub type Ports = Vec<Port>;

// Encode Ports as CBOR and append to output stream
#[doc(hidden)]
#[allow(unused_mut)]
pub fn encode_ports<W: wasmbus_rpc::cbor::Write>(
    mut e: &mut wasmbus_rpc::cbor::Encoder<W>,
    val: &Ports,
) -> RpcResult<()>
where
    <W as wasmbus_rpc::cbor::Write>::Error: std::fmt::Display,
{
    e.array(val.len() as u64)?;
    for item in val.iter() {
        encode_port(e, item)?;
    }
    Ok(())
}

// Decode Ports from cbor input stream
#[doc(hidden)]
pub fn decode_ports(
    d: &mut wasmbus_rpc::cbor::Decoder<'_>,
) -> Result<Ports, RpcError> {
    let __result = {
        if let Some(n) = d.array()? {
            let mut arr: Vec<Port> = Vec::with_capacity(n as usize);
            for _ in 0..(n as usize) {
                arr.push(decode_port(d).map_err(|e| {
                    format!(
                        "decoding 'jclmnop.dtbh.interface.common#Port': {}",
                        e
                    )
                })?)
            }
            arr
        } else {
            // indefinite array
            let mut arr: Vec<Port> = Vec::new();
            loop {
                match d.datatype() {
                    Err(_) => break,
                    Ok(wasmbus_rpc::cbor::Type::Break) => break,
                    Ok(_) => arr.push(decode_port(d).map_err(|e| {
                        format!(
                            "decoding 'jclmnop.dtbh.interface.common#Port': {}",
                            e
                        )
                    })?),
                }
            }
            arr
        }
    };
    Ok(__result)
}
#[derive(Clone, Debug, Default, Deserialize, Eq, PartialEq, Serialize)]
pub struct Subdomain {
    #[serde(rename = "openPorts")]
    pub open_ports: Ports,
    #[serde(default)]
    pub subdomain: String,
}

// Encode Subdomain as CBOR and append to output stream
#[doc(hidden)]
#[allow(unused_mut)]
pub fn encode_subdomain<W: wasmbus_rpc::cbor::Write>(
    mut e: &mut wasmbus_rpc::cbor::Encoder<W>,
    val: &Subdomain,
) -> RpcResult<()>
where
    <W as wasmbus_rpc::cbor::Write>::Error: std::fmt::Display,
{
    e.map(2)?;
    e.str("openPorts")?;
    encode_ports(e, &val.open_ports)?;
    e.str("subdomain")?;
    e.str(&val.subdomain)?;
    Ok(())
}

// Decode Subdomain from cbor input stream
#[doc(hidden)]
pub fn decode_subdomain(
    d: &mut wasmbus_rpc::cbor::Decoder<'_>,
) -> Result<Subdomain, RpcError> {
    let __result = {
        let mut open_ports: Option<Ports> = None;
        let mut subdomain: Option<String> = None;

        let is_array = match d.datatype()? {
            wasmbus_rpc::cbor::Type::Array => true,
            wasmbus_rpc::cbor::Type::Map => false,
            _ => {
                return Err(RpcError::Deser(
                    "decoding struct Subdomain, expected array or map"
                        .to_string(),
                ))
            }
        };
        if is_array {
            let len = d.fixed_array()?;
            for __i in 0..(len as usize) {
                match __i {
            0 => open_ports = Some(decode_ports(d).map_err(|e| format!("decoding 'jclmnop.dtbh.interface.common#Ports': {}", e))?),1 => subdomain = Some(d.str()?.to_string()),
                    _ => d.skip()?,
                    }
            }
        } else {
            let len = d.fixed_map()?;
            for __i in 0..(len as usize) {
                match d.str()? {
                "openPorts" => open_ports = Some(decode_ports(d).map_err(|e| format!("decoding 'jclmnop.dtbh.interface.common#Ports': {}", e))?),"subdomain" => subdomain = Some(d.str()?.to_string()),         _ => d.skip()?,
                    }
            }
        }
        Subdomain {
            open_ports: if let Some(__x) = open_ports {
                __x
            } else {
                return Err(RpcError::Deser(
                    "missing field Subdomain.open_ports (#0)".to_string(),
                ));
            },

            subdomain: if let Some(__x) = subdomain {
                __x
            } else {
                return Err(RpcError::Deser(
                    "missing field Subdomain.subdomain (#1)".to_string(),
                ));
            },
        }
    };
    Ok(__result)
}
pub type Subdomains = Vec<Subdomain>;

// Encode Subdomains as CBOR and append to output stream
#[doc(hidden)]
#[allow(unused_mut)]
pub fn encode_subdomains<W: wasmbus_rpc::cbor::Write>(
    mut e: &mut wasmbus_rpc::cbor::Encoder<W>,
    val: &Subdomains,
) -> RpcResult<()>
where
    <W as wasmbus_rpc::cbor::Write>::Error: std::fmt::Display,
{
    e.array(val.len() as u64)?;
    for item in val.iter() {
        encode_subdomain(e, item)?;
    }
    Ok(())
}

// Decode Subdomains from cbor input stream
#[doc(hidden)]
pub fn decode_subdomains(
    d: &mut wasmbus_rpc::cbor::Decoder<'_>,
) -> Result<Subdomains, RpcError> {
    let __result = {
        if let Some(n) = d.array()? {
            let mut arr: Vec<Subdomain> = Vec::with_capacity(n as usize);
            for _ in 0..(n as usize) {
                arr.push(decode_subdomain(d).map_err(|e| format!("decoding 'jclmnop.dtbh.interface.common#Subdomain': {}", e))?)
            }
            arr
        } else {
            // indefinite array
            let mut arr: Vec<Subdomain> = Vec::new();
            loop {
                match d.datatype() {
                                Err(_) => break,
                                Ok(wasmbus_rpc::cbor::Type::Break) => break,
                                Ok(_) => arr.push(decode_subdomain(d).map_err(|e| format!("decoding 'jclmnop.dtbh.interface.common#Subdomain': {}", e))?)
                            }
            }
            arr
        }
    };
    Ok(__result)
}
