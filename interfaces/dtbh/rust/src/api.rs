// This file is @generated by wasmcloud/weld-codegen 0.7.0.
// It is not intended for manual editing.
// namespace: jclmnop.dtbh.interface.api

#[allow(unused_imports)]
use async_trait::async_trait;
#[allow(unused_imports)]
use serde::{Deserialize, Serialize};
#[allow(unused_imports)]
use std::{borrow::Borrow, borrow::Cow, io::Write, string::ToString};
#[allow(unused_imports)]
use wasmbus_rpc::{
    cbor::*,
    common::{
        deserialize, message_format, serialize, Context, Message,
        MessageDispatch, MessageFormat, SendOpts, Transport,
    },
    error::{RpcError, RpcResult},
    Timestamp,
};

#[allow(dead_code)]
pub const SMITHY_VERSION: &str = "1.0";

#[derive(Clone, Debug, Default, Deserialize, Eq, PartialEq, Serialize)]
pub struct ScanRequest {
    #[serde(default)]
    pub targets: String,
    #[serde(rename = "userAgentTag")]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub user_agent_tag: Option<String>,
    #[serde(rename = "userId")]
    #[serde(default)]
    pub user_id: String,
}

// Encode ScanRequest as CBOR and append to output stream
#[doc(hidden)]
#[allow(unused_mut)]
pub fn encode_scan_request<W: wasmbus_rpc::cbor::Write>(
    mut e: &mut wasmbus_rpc::cbor::Encoder<W>,
    val: &ScanRequest,
) -> RpcResult<()>
where
    <W as wasmbus_rpc::cbor::Write>::Error: std::fmt::Display,
{
    e.map(3)?;
    e.str("targets")?;
    e.str(&val.targets)?;
    if let Some(val) = val.user_agent_tag.as_ref() {
        e.str("userAgentTag")?;
        e.str(val)?;
    } else {
        e.null()?;
    }
    e.str("userId")?;
    e.str(&val.user_id)?;
    Ok(())
}

// Decode ScanRequest from cbor input stream
#[doc(hidden)]
pub fn decode_scan_request(
    d: &mut wasmbus_rpc::cbor::Decoder<'_>,
) -> Result<ScanRequest, RpcError> {
    let __result = {
        let mut targets: Option<String> = None;
        let mut user_agent_tag: Option<Option<String>> = Some(None);
        let mut user_id: Option<String> = None;

        let is_array = match d.datatype()? {
            wasmbus_rpc::cbor::Type::Array => true,
            wasmbus_rpc::cbor::Type::Map => false,
            _ => {
                return Err(RpcError::Deser(
                    "decoding struct ScanRequest, expected array or map"
                        .to_string(),
                ))
            }
        };
        if is_array {
            let len = d.fixed_array()?;
            for __i in 0..(len as usize) {
                match __i {
                    0 => targets = Some(d.str()?.to_string()),
                    1 => {
                        user_agent_tag =
                            if wasmbus_rpc::cbor::Type::Null == d.datatype()? {
                                d.skip()?;
                                Some(None)
                            } else {
                                Some(Some(d.str()?.to_string()))
                            }
                    }
                    2 => user_id = Some(d.str()?.to_string()),
                    _ => d.skip()?,
                }
            }
        } else {
            let len = d.fixed_map()?;
            for __i in 0..(len as usize) {
                match d.str()? {
                    "targets" => targets = Some(d.str()?.to_string()),
                    "userAgentTag" => {
                        user_agent_tag =
                            if wasmbus_rpc::cbor::Type::Null == d.datatype()? {
                                d.skip()?;
                                Some(None)
                            } else {
                                Some(Some(d.str()?.to_string()))
                            }
                    }
                    "userId" => user_id = Some(d.str()?.to_string()),
                    _ => d.skip()?,
                }
            }
        }
        ScanRequest {
            targets: if let Some(__x) = targets {
                __x
            } else {
                return Err(RpcError::Deser(
                    "missing field ScanRequest.targets (#0)".to_string(),
                ));
            },
            user_agent_tag: user_agent_tag.unwrap(),

            user_id: if let Some(__x) = user_id {
                __x
            } else {
                return Err(RpcError::Deser(
                    "missing field ScanRequest.user_id (#2)".to_string(),
                ));
            },
        }
    };
    Ok(__result)
}
pub type Targets = Vec<String>;

// Encode Targets as CBOR and append to output stream
#[doc(hidden)]
#[allow(unused_mut)]
pub fn encode_targets<W: wasmbus_rpc::cbor::Write>(
    mut e: &mut wasmbus_rpc::cbor::Encoder<W>,
    val: &Targets,
) -> RpcResult<()>
where
    <W as wasmbus_rpc::cbor::Write>::Error: std::fmt::Display,
{
    e.array(val.len() as u64)?;
    for item in val.iter() {
        e.str(item)?;
    }
    Ok(())
}

// Decode Targets from cbor input stream
#[doc(hidden)]
pub fn decode_targets(
    d: &mut wasmbus_rpc::cbor::Decoder<'_>,
) -> Result<Targets, RpcError> {
    let __result = {
        if let Some(n) = d.array()? {
            let mut arr: Vec<String> = Vec::with_capacity(n as usize);
            for _ in 0..(n as usize) {
                arr.push(d.str()?.to_string())
            }
            arr
        } else {
            // indefinite array
            let mut arr: Vec<String> = Vec::new();
            loop {
                match d.datatype() {
                    Err(_) => break,
                    Ok(wasmbus_rpc::cbor::Type::Break) => break,
                    Ok(_) => arr.push(d.str()?.to_string()),
                }
            }
            arr
        }
    };
    Ok(__result)
}
