// This file is @generated by wasmcloud/weld-codegen 0.7.0.
// It is not intended for manual editing.
// namespace: org.wasmcloud.interface.surrealdb

#[allow(unused_imports)]
use async_trait::async_trait;
#[allow(unused_imports)]
use serde::{Deserialize, Serialize};
#[allow(unused_imports)]
use std::{borrow::Borrow, borrow::Cow, io::Write, string::ToString};
#[allow(unused_imports)]
use wasmbus_rpc::{
    cbor::*,
    common::{
        deserialize, message_format, serialize, Context, Message, MessageDispatch, MessageFormat,
        SendOpts, Transport,
    },
    error::{RpcError, RpcResult},
    Timestamp,
};

#[allow(dead_code)]
pub const SMITHY_VERSION: &str = "1.0";

/// Either a username and password or a JWT
#[derive(Clone, Debug, Default, Deserialize, Eq, PartialEq, Serialize)]
pub struct AuthParams {
    #[serde(default)]
    pub password: String,
    #[serde(default)]
    pub username: String,
}

// Encode AuthParams as CBOR and append to output stream
#[doc(hidden)]
#[allow(unused_mut)]
pub fn encode_auth_params<W: wasmbus_rpc::cbor::Write>(
    mut e: &mut wasmbus_rpc::cbor::Encoder<W>,
    val: &AuthParams,
) -> RpcResult<()>
where
    <W as wasmbus_rpc::cbor::Write>::Error: std::fmt::Display,
{
    e.map(2)?;
    e.str("password")?;
    e.str(&val.password)?;
    e.str("username")?;
    e.str(&val.username)?;
    Ok(())
}

// Decode AuthParams from cbor input stream
#[doc(hidden)]
pub fn decode_auth_params(d: &mut wasmbus_rpc::cbor::Decoder<'_>) -> Result<AuthParams, RpcError> {
    let __result = {
        let mut password: Option<String> = None;
        let mut username: Option<String> = None;

        let is_array = match d.datatype()? {
            wasmbus_rpc::cbor::Type::Array => true,
            wasmbus_rpc::cbor::Type::Map => false,
            _ => {
                return Err(RpcError::Deser(
                    "decoding struct AuthParams, expected array or map".to_string(),
                ))
            }
        };
        if is_array {
            let len = d.fixed_array()?;
            for __i in 0..(len as usize) {
                match __i {
                    0 => password = Some(d.str()?.to_string()),
                    1 => username = Some(d.str()?.to_string()),
                    _ => d.skip()?,
                }
            }
        } else {
            let len = d.fixed_map()?;
            for __i in 0..(len as usize) {
                match d.str()? {
                    "password" => password = Some(d.str()?.to_string()),
                    "username" => username = Some(d.str()?.to_string()),
                    _ => d.skip()?,
                }
            }
        }
        AuthParams {
            password: if let Some(__x) = password {
                __x
            } else {
                return Err(RpcError::Deser(
                    "missing field AuthParams.password (#0)".to_string(),
                ));
            },

            username: if let Some(__x) = username {
                __x
            } else {
                return Err(RpcError::Deser(
                    "missing field AuthParams.username (#1)".to_string(),
                ));
            },
        }
    };
    Ok(__result)
}
#[derive(Clone, Debug, Default, Deserialize, Eq, PartialEq, Serialize)]
pub struct AuthenticateResponse {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub error: Option<SurrealDbError>,
    #[serde(default)]
    pub success: bool,
}

// Encode AuthenticateResponse as CBOR and append to output stream
#[doc(hidden)]
#[allow(unused_mut)]
pub fn encode_authenticate_response<W: wasmbus_rpc::cbor::Write>(
    mut e: &mut wasmbus_rpc::cbor::Encoder<W>,
    val: &AuthenticateResponse,
) -> RpcResult<()>
where
    <W as wasmbus_rpc::cbor::Write>::Error: std::fmt::Display,
{
    e.map(2)?;
    if let Some(val) = val.error.as_ref() {
        e.str("error")?;
        encode_surreal_db_error(e, val)?;
    } else {
        e.null()?;
    }
    e.str("success")?;
    e.bool(val.success)?;
    Ok(())
}

// Decode AuthenticateResponse from cbor input stream
#[doc(hidden)]
pub fn decode_authenticate_response(
    d: &mut wasmbus_rpc::cbor::Decoder<'_>,
) -> Result<AuthenticateResponse, RpcError> {
    let __result = {
        let mut error: Option<Option<SurrealDbError>> = Some(None);
        let mut success: Option<bool> = None;

        let is_array = match d.datatype()? {
            wasmbus_rpc::cbor::Type::Array => true,
            wasmbus_rpc::cbor::Type::Map => false,
            _ => {
                return Err(RpcError::Deser(
                    "decoding struct AuthenticateResponse, expected array or map".to_string(),
                ))
            }
        };
        if is_array {
            let len = d.fixed_array()?;
            for __i in 0..(len as usize) {
                match __i {
                    0 => {
                        error = if wasmbus_rpc::cbor::Type::Null == d.datatype()? {
                            d.skip()?;
                            Some(None)
                        } else {
                            Some(Some( decode_surreal_db_error(d).map_err(|e| format!("decoding 'org.wasmcloud.interface.surrealdb#SurrealDbError': {}", e))? ))
                        }
                    }
                    1 => success = Some(d.bool()?),
                    _ => d.skip()?,
                }
            }
        } else {
            let len = d.fixed_map()?;
            for __i in 0..(len as usize) {
                match d.str()? {
                    "error" => {
                        error = if wasmbus_rpc::cbor::Type::Null == d.datatype()? {
                            d.skip()?;
                            Some(None)
                        } else {
                            Some(Some( decode_surreal_db_error(d).map_err(|e| format!("decoding 'org.wasmcloud.interface.surrealdb#SurrealDbError': {}", e))? ))
                        }
                    }
                    "success" => success = Some(d.bool()?),
                    _ => d.skip()?,
                }
            }
        }
        AuthenticateResponse {
            error: error.unwrap(),

            success: if let Some(__x) = success {
                __x
            } else {
                return Err(RpcError::Deser(
                    "missing field AuthenticateResponse.success (#1)".to_string(),
                ));
            },
        }
    };
    Ok(__result)
}
/// List of bindings for a query. Value must be serialised.
pub type Bindings = Vec<String>;

// Encode Bindings as CBOR and append to output stream
#[doc(hidden)]
#[allow(unused_mut)]
pub fn encode_bindings<W: wasmbus_rpc::cbor::Write>(
    mut e: &mut wasmbus_rpc::cbor::Encoder<W>,
    val: &Bindings,
) -> RpcResult<()>
where
    <W as wasmbus_rpc::cbor::Write>::Error: std::fmt::Display,
{
    e.array(val.len() as u64)?;
    for item in val.iter() {
        e.str(item)?;
    }
    Ok(())
}

// Decode Bindings from cbor input stream
#[doc(hidden)]
pub fn decode_bindings(d: &mut wasmbus_rpc::cbor::Decoder<'_>) -> Result<Bindings, RpcError> {
    let __result = {
        if let Some(n) = d.array()? {
            let mut arr: Vec<String> = Vec::with_capacity(n as usize);
            for _ in 0..(n as usize) {
                arr.push(d.str()?.to_string())
            }
            arr
        } else {
            // indefinite array
            let mut arr: Vec<String> = Vec::new();
            loop {
                match d.datatype() {
                    Err(_) => break,
                    Ok(wasmbus_rpc::cbor::Type::Break) => break,
                    Ok(_) => arr.push(d.str()?.to_string()),
                }
            }
            arr
        }
    };
    Ok(__result)
}
pub type Queries = Vec<String>;

// Encode Queries as CBOR and append to output stream
#[doc(hidden)]
#[allow(unused_mut)]
pub fn encode_queries<W: wasmbus_rpc::cbor::Write>(
    mut e: &mut wasmbus_rpc::cbor::Encoder<W>,
    val: &Queries,
) -> RpcResult<()>
where
    <W as wasmbus_rpc::cbor::Write>::Error: std::fmt::Display,
{
    e.array(val.len() as u64)?;
    for item in val.iter() {
        e.str(item)?;
    }
    Ok(())
}

// Decode Queries from cbor input stream
#[doc(hidden)]
pub fn decode_queries(d: &mut wasmbus_rpc::cbor::Decoder<'_>) -> Result<Queries, RpcError> {
    let __result = {
        if let Some(n) = d.array()? {
            let mut arr: Vec<String> = Vec::with_capacity(n as usize);
            for _ in 0..(n as usize) {
                arr.push(d.str()?.to_string())
            }
            arr
        } else {
            // indefinite array
            let mut arr: Vec<String> = Vec::new();
            loop {
                match d.datatype() {
                    Err(_) => break,
                    Ok(wasmbus_rpc::cbor::Type::Break) => break,
                    Ok(_) => arr.push(d.str()?.to_string()),
                }
            }
            arr
        }
    };
    Ok(__result)
}
/// A query can be a combination of any
/// types of SurrealQL query: SELECT, CREATE, UPDATE, TRANSACTION, etc.
///
/// `queries` and `bindings` are both lists of lists of bytes. `bindings[i]`
/// contains the bindings for `statements[i]`. If `statements[i]` doesn't require
/// any bindings then `bindings[i]` should be an empty list.
///
/// Each query is executed in sequence.
#[derive(Clone, Debug, Default, Deserialize, Eq, PartialEq, Serialize)]
pub struct QueryRequest {
    /// The binding values for each statement. Can either be key value pairs or a
    /// Struct, serialised into a string. If a query doesn't require any bindings
    /// then an empty list should be included.
    pub bindings: Bindings,
    /// A list of SurrealQL statements, each represented as a string. If user input is being
    /// inserted into the statement, it is recommended to use binding variables
    /// and values to avoid SQL injection.
    pub queries: Queries,
    /// The scope in which the query should be executed for. If no scope is
    /// provided then the default namespace and database will be used, with
    /// the Root scope configured for this database.
    ///
    /// If using a custom scope, perhaps for a user, then this scope must have
    /// been set up beforehand otherwise the query will fail. The query will
    /// also fail if a custom scope is provided but the authentication credentials
    /// are invalid.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub scope: Option<Scope>,
}

// Encode QueryRequest as CBOR and append to output stream
#[doc(hidden)]
#[allow(unused_mut)]
pub fn encode_query_request<W: wasmbus_rpc::cbor::Write>(
    mut e: &mut wasmbus_rpc::cbor::Encoder<W>,
    val: &QueryRequest,
) -> RpcResult<()>
where
    <W as wasmbus_rpc::cbor::Write>::Error: std::fmt::Display,
{
    e.map(3)?;
    e.str("bindings")?;
    encode_bindings(e, &val.bindings)?;
    e.str("queries")?;
    encode_queries(e, &val.queries)?;
    if let Some(val) = val.scope.as_ref() {
        e.str("scope")?;
        encode_scope(e, val)?;
    } else {
        e.null()?;
    }
    Ok(())
}

// Decode QueryRequest from cbor input stream
#[doc(hidden)]
pub fn decode_query_request(
    d: &mut wasmbus_rpc::cbor::Decoder<'_>,
) -> Result<QueryRequest, RpcError> {
    let __result = {
        let mut bindings: Option<Bindings> = None;
        let mut queries: Option<Queries> = None;
        let mut scope: Option<Option<Scope>> = Some(None);

        let is_array = match d.datatype()? {
            wasmbus_rpc::cbor::Type::Array => true,
            wasmbus_rpc::cbor::Type::Map => false,
            _ => {
                return Err(RpcError::Deser(
                    "decoding struct QueryRequest, expected array or map".to_string(),
                ))
            }
        };
        if is_array {
            let len = d.fixed_array()?;
            for __i in 0..(len as usize) {
                match __i {
                    0 => {
                        bindings = Some(decode_bindings(d).map_err(|e| {
                            format!(
                                "decoding 'org.wasmcloud.interface.surrealdb#Bindings': {}",
                                e
                            )
                        })?)
                    }
                    1 => {
                        queries = Some(decode_queries(d).map_err(|e| {
                            format!(
                                "decoding 'org.wasmcloud.interface.surrealdb#Queries': {}",
                                e
                            )
                        })?)
                    }
                    2 => {
                        scope = if wasmbus_rpc::cbor::Type::Null == d.datatype()? {
                            d.skip()?;
                            Some(None)
                        } else {
                            Some(Some(decode_scope(d).map_err(|e| {
                                format!("decoding 'org.wasmcloud.interface.surrealdb#Scope': {}", e)
                            })?))
                        }
                    }

                    _ => d.skip()?,
                }
            }
        } else {
            let len = d.fixed_map()?;
            for __i in 0..(len as usize) {
                match d.str()? {
                    "bindings" => {
                        bindings = Some(decode_bindings(d).map_err(|e| {
                            format!(
                                "decoding 'org.wasmcloud.interface.surrealdb#Bindings': {}",
                                e
                            )
                        })?)
                    }
                    "queries" => {
                        queries = Some(decode_queries(d).map_err(|e| {
                            format!(
                                "decoding 'org.wasmcloud.interface.surrealdb#Queries': {}",
                                e
                            )
                        })?)
                    }
                    "scope" => {
                        scope = if wasmbus_rpc::cbor::Type::Null == d.datatype()? {
                            d.skip()?;
                            Some(None)
                        } else {
                            Some(Some(decode_scope(d).map_err(|e| {
                                format!("decoding 'org.wasmcloud.interface.surrealdb#Scope': {}", e)
                            })?))
                        }
                    }
                    _ => d.skip()?,
                }
            }
        }
        QueryRequest {
            bindings: if let Some(__x) = bindings {
                __x
            } else {
                return Err(RpcError::Deser(
                    "missing field QueryRequest.bindings (#0)".to_string(),
                ));
            },

            queries: if let Some(__x) = queries {
                __x
            } else {
                return Err(RpcError::Deser(
                    "missing field QueryRequest.queries (#1)".to_string(),
                ));
            },
            scope: scope.unwrap(),
        }
    };
    Ok(__result)
}
/// Result of querying a SurrealDb instance. If error value is present, then
/// the query failed.
#[derive(Clone, Debug, Default, Deserialize, Eq, PartialEq, Serialize)]
pub struct QueryResponse {
    /// Details of any error(s) that caused a query to fail. If this is empty,
    /// then all the queries succeeded.
    pub errors: SurrealDbErrors,
    /// The data returend from each query, serialised into bytes. Will be empty if no data
    /// was retrieved.
    ///
    /// SurrealDB responses are usually of type `IndexMap<usize, surrealdb::Result<Vec<surrealdb::sql::Value>>>`,
    /// but here the Results are unwrapped and any errors will be included as a SurrealDbError in the QueryResponse.
    ///
    /// Each `Vec<u8>` can be deserialised directly into a `Vec<T>` where `T` is a struct with the required fields.
    pub response: ResponseData,
}

// Encode QueryResponse as CBOR and append to output stream
#[doc(hidden)]
#[allow(unused_mut)]
pub fn encode_query_response<W: wasmbus_rpc::cbor::Write>(
    mut e: &mut wasmbus_rpc::cbor::Encoder<W>,
    val: &QueryResponse,
) -> RpcResult<()>
where
    <W as wasmbus_rpc::cbor::Write>::Error: std::fmt::Display,
{
    e.map(2)?;
    e.str("errors")?;
    encode_surreal_db_errors(e, &val.errors)?;
    e.str("response")?;
    encode_response_data(e, &val.response)?;
    Ok(())
}

// Decode QueryResponse from cbor input stream
#[doc(hidden)]
pub fn decode_query_response(
    d: &mut wasmbus_rpc::cbor::Decoder<'_>,
) -> Result<QueryResponse, RpcError> {
    let __result =
        {
            let mut errors: Option<SurrealDbErrors> = None;
            let mut response: Option<ResponseData> = None;

            let is_array = match d.datatype()? {
                wasmbus_rpc::cbor::Type::Array => true,
                wasmbus_rpc::cbor::Type::Map => false,
                _ => {
                    return Err(RpcError::Deser(
                        "decoding struct QueryResponse, expected array or map".to_string(),
                    ))
                }
            };
            if is_array {
                let len = d.fixed_array()?;
                for __i in 0..(len as usize) {
                    match __i {
                        0 => errors = Some(decode_surreal_db_errors(d).map_err(|e| {
                            format!(
                                "decoding 'org.wasmcloud.interface.surrealdb#SurrealDbErrors': {}",
                                e
                            )
                        })?),
                        1 => {
                            response = Some(decode_response_data(d).map_err(|e| {
                                format!(
                                    "decoding 'org.wasmcloud.interface.surrealdb#ResponseData': {}",
                                    e
                                )
                            })?)
                        }
                        _ => d.skip()?,
                    }
                }
            } else {
                let len = d.fixed_map()?;
                for __i in 0..(len as usize) {
                    match d.str()? {
                        "errors" => errors = Some(decode_surreal_db_errors(d).map_err(|e| {
                            format!(
                                "decoding 'org.wasmcloud.interface.surrealdb#SurrealDbErrors': {}",
                                e
                            )
                        })?),
                        "response" => {
                            response = Some(decode_response_data(d).map_err(|e| {
                                format!(
                                    "decoding 'org.wasmcloud.interface.surrealdb#ResponseData': {}",
                                    e
                                )
                            })?)
                        }
                        _ => d.skip()?,
                    }
                }
            }
            QueryResponse {
                errors: if let Some(__x) = errors {
                    __x
                } else {
                    return Err(RpcError::Deser(
                        "missing field QueryResponse.errors (#0)".to_string(),
                    ));
                },

                response: if let Some(__x) = response {
                    __x
                } else {
                    return Err(RpcError::Deser(
                        "missing field QueryResponse.response (#1)".to_string(),
                    ));
                },
            }
        };
    Ok(__result)
}
/// List of responses for each query that was executed.
pub type QueryResponses = Vec<QueryResponse>;

// Encode QueryResponses as CBOR and append to output stream
#[doc(hidden)]
#[allow(unused_mut)]
pub fn encode_query_responses<W: wasmbus_rpc::cbor::Write>(
    mut e: &mut wasmbus_rpc::cbor::Encoder<W>,
    val: &QueryResponses,
) -> RpcResult<()>
where
    <W as wasmbus_rpc::cbor::Write>::Error: std::fmt::Display,
{
    e.array(val.len() as u64)?;
    for item in val.iter() {
        encode_query_response(e, item)?;
    }
    Ok(())
}

// Decode QueryResponses from cbor input stream
#[doc(hidden)]
pub fn decode_query_responses(
    d: &mut wasmbus_rpc::cbor::Decoder<'_>,
) -> Result<QueryResponses, RpcError> {
    let __result = {
        if let Some(n) = d.array()? {
            let mut arr: Vec<QueryResponse> = Vec::with_capacity(n as usize);
            for _ in 0..(n as usize) {
                arr.push(decode_query_response(d).map_err(|e| {
                    format!(
                        "decoding 'org.wasmcloud.interface.surrealdb#QueryResponse': {}",
                        e
                    )
                })?)
            }
            arr
        } else {
            // indefinite array
            let mut arr: Vec<QueryResponse> = Vec::new();
            loop {
                match d.datatype() {
                    Err(_) => break,
                    Ok(wasmbus_rpc::cbor::Type::Break) => break,
                    Ok(_) => arr.push(decode_query_response(d).map_err(|e| {
                        format!(
                            "decoding 'org.wasmcloud.interface.surrealdb#QueryResponse': {}",
                            e
                        )
                    })?),
                }
            }
            arr
        }
    };
    Ok(__result)
}
pub type ResponseData = Vec<Vec<u8>>;

// Encode ResponseData as CBOR and append to output stream
#[doc(hidden)]
#[allow(unused_mut)]
pub fn encode_response_data<W: wasmbus_rpc::cbor::Write>(
    mut e: &mut wasmbus_rpc::cbor::Encoder<W>,
    val: &ResponseData,
) -> RpcResult<()>
where
    <W as wasmbus_rpc::cbor::Write>::Error: std::fmt::Display,
{
    e.array(val.len() as u64)?;
    for item in val.iter() {
        e.bytes(item)?;
    }
    Ok(())
}

// Decode ResponseData from cbor input stream
#[doc(hidden)]
pub fn decode_response_data(
    d: &mut wasmbus_rpc::cbor::Decoder<'_>,
) -> Result<ResponseData, RpcError> {
    let __result = {
        if let Some(n) = d.array()? {
            let mut arr: Vec<Vec<u8>> = Vec::with_capacity(n as usize);
            for _ in 0..(n as usize) {
                arr.push(d.bytes()?.to_vec())
            }
            arr
        } else {
            // indefinite array
            let mut arr: Vec<Vec<u8>> = Vec::new();
            loop {
                match d.datatype() {
                    Err(_) => break,
                    Ok(wasmbus_rpc::cbor::Type::Break) => break,
                    Ok(_) => arr.push(d.bytes()?.to_vec()),
                }
            }
            arr
        }
    };
    Ok(__result)
}
/// The scope in which a query should be executed. All fields are optional,
/// but namespace and database must have defaults configured in the provider.
#[derive(Clone, Debug, Default, Deserialize, Eq, PartialEq, Serialize)]
pub struct Scope {
    /// Authentication paramaters, only required if scope is specified.
    #[serde(rename = "authParams")]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub auth_params: Option<AuthParams>,
    /// The database to be used, defaults to user configured default value.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub database: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub jwt: Option<String>,
    /// The namespace to be used, defaults to user configured default value.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub namespace: Option<String>,
    /// The scope to be used, defaults to Root.
    #[serde(rename = "scopeName")]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub scope_name: Option<String>,
}

// Encode Scope as CBOR and append to output stream
#[doc(hidden)]
#[allow(unused_mut)]
pub fn encode_scope<W: wasmbus_rpc::cbor::Write>(
    mut e: &mut wasmbus_rpc::cbor::Encoder<W>,
    val: &Scope,
) -> RpcResult<()>
where
    <W as wasmbus_rpc::cbor::Write>::Error: std::fmt::Display,
{
    e.map(5)?;
    if let Some(val) = val.auth_params.as_ref() {
        e.str("authParams")?;
        encode_auth_params(e, val)?;
    } else {
        e.null()?;
    }
    if let Some(val) = val.database.as_ref() {
        e.str("database")?;
        e.str(val)?;
    } else {
        e.null()?;
    }
    if let Some(val) = val.jwt.as_ref() {
        e.str("jwt")?;
        e.str(val)?;
    } else {
        e.null()?;
    }
    if let Some(val) = val.namespace.as_ref() {
        e.str("namespace")?;
        e.str(val)?;
    } else {
        e.null()?;
    }
    if let Some(val) = val.scope_name.as_ref() {
        e.str("scopeName")?;
        e.str(val)?;
    } else {
        e.null()?;
    }
    Ok(())
}

// Decode Scope from cbor input stream
#[doc(hidden)]
pub fn decode_scope(d: &mut wasmbus_rpc::cbor::Decoder<'_>) -> Result<Scope, RpcError> {
    let __result = {
        let mut auth_params: Option<Option<AuthParams>> = Some(None);
        let mut database: Option<Option<String>> = Some(None);
        let mut jwt: Option<Option<String>> = Some(None);
        let mut namespace: Option<Option<String>> = Some(None);
        let mut scope_name: Option<Option<String>> = Some(None);

        let is_array = match d.datatype()? {
            wasmbus_rpc::cbor::Type::Array => true,
            wasmbus_rpc::cbor::Type::Map => false,
            _ => {
                return Err(RpcError::Deser(
                    "decoding struct Scope, expected array or map".to_string(),
                ))
            }
        };
        if is_array {
            let len = d.fixed_array()?;
            for __i in 0..(len as usize) {
                match __i {
                    0 => {
                        auth_params = if wasmbus_rpc::cbor::Type::Null == d.datatype()? {
                            d.skip()?;
                            Some(None)
                        } else {
                            Some(Some(decode_auth_params(d).map_err(|e| {
                                format!(
                                    "decoding 'org.wasmcloud.interface.surrealdb#AuthParams': {}",
                                    e
                                )
                            })?))
                        }
                    }
                    1 => {
                        database = if wasmbus_rpc::cbor::Type::Null == d.datatype()? {
                            d.skip()?;
                            Some(None)
                        } else {
                            Some(Some(d.str()?.to_string()))
                        }
                    }
                    2 => {
                        jwt = if wasmbus_rpc::cbor::Type::Null == d.datatype()? {
                            d.skip()?;
                            Some(None)
                        } else {
                            Some(Some(d.str()?.to_string()))
                        }
                    }
                    3 => {
                        namespace = if wasmbus_rpc::cbor::Type::Null == d.datatype()? {
                            d.skip()?;
                            Some(None)
                        } else {
                            Some(Some(d.str()?.to_string()))
                        }
                    }
                    4 => {
                        scope_name = if wasmbus_rpc::cbor::Type::Null == d.datatype()? {
                            d.skip()?;
                            Some(None)
                        } else {
                            Some(Some(d.str()?.to_string()))
                        }
                    }

                    _ => d.skip()?,
                }
            }
        } else {
            let len = d.fixed_map()?;
            for __i in 0..(len as usize) {
                match d.str()? {
                    "authParams" => {
                        auth_params = if wasmbus_rpc::cbor::Type::Null == d.datatype()? {
                            d.skip()?;
                            Some(None)
                        } else {
                            Some(Some(decode_auth_params(d).map_err(|e| {
                                format!(
                                    "decoding 'org.wasmcloud.interface.surrealdb#AuthParams': {}",
                                    e
                                )
                            })?))
                        }
                    }
                    "database" => {
                        database = if wasmbus_rpc::cbor::Type::Null == d.datatype()? {
                            d.skip()?;
                            Some(None)
                        } else {
                            Some(Some(d.str()?.to_string()))
                        }
                    }
                    "jwt" => {
                        jwt = if wasmbus_rpc::cbor::Type::Null == d.datatype()? {
                            d.skip()?;
                            Some(None)
                        } else {
                            Some(Some(d.str()?.to_string()))
                        }
                    }
                    "namespace" => {
                        namespace = if wasmbus_rpc::cbor::Type::Null == d.datatype()? {
                            d.skip()?;
                            Some(None)
                        } else {
                            Some(Some(d.str()?.to_string()))
                        }
                    }
                    "scopeName" => {
                        scope_name = if wasmbus_rpc::cbor::Type::Null == d.datatype()? {
                            d.skip()?;
                            Some(None)
                        } else {
                            Some(Some(d.str()?.to_string()))
                        }
                    }
                    _ => d.skip()?,
                }
            }
        }
        Scope {
            auth_params: auth_params.unwrap(),
            database: database.unwrap(),
            jwt: jwt.unwrap(),
            namespace: namespace.unwrap(),
            scope_name: scope_name.unwrap(),
        }
    };
    Ok(__result)
}
#[derive(Clone, Debug, Default, Deserialize, Eq, PartialEq, Serialize)]
pub struct SignInResponse {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub error: Option<SurrealDbError>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub jwt: Option<String>,
    #[serde(default)]
    pub success: bool,
}

// Encode SignInResponse as CBOR and append to output stream
#[doc(hidden)]
#[allow(unused_mut)]
pub fn encode_sign_in_response<W: wasmbus_rpc::cbor::Write>(
    mut e: &mut wasmbus_rpc::cbor::Encoder<W>,
    val: &SignInResponse,
) -> RpcResult<()>
where
    <W as wasmbus_rpc::cbor::Write>::Error: std::fmt::Display,
{
    e.map(3)?;
    if let Some(val) = val.error.as_ref() {
        e.str("error")?;
        encode_surreal_db_error(e, val)?;
    } else {
        e.null()?;
    }
    if let Some(val) = val.jwt.as_ref() {
        e.str("jwt")?;
        e.str(val)?;
    } else {
        e.null()?;
    }
    e.str("success")?;
    e.bool(val.success)?;
    Ok(())
}

// Decode SignInResponse from cbor input stream
#[doc(hidden)]
pub fn decode_sign_in_response(
    d: &mut wasmbus_rpc::cbor::Decoder<'_>,
) -> Result<SignInResponse, RpcError> {
    let __result = {
        let mut error: Option<Option<SurrealDbError>> = Some(None);
        let mut jwt: Option<Option<String>> = Some(None);
        let mut success: Option<bool> = None;

        let is_array = match d.datatype()? {
            wasmbus_rpc::cbor::Type::Array => true,
            wasmbus_rpc::cbor::Type::Map => false,
            _ => {
                return Err(RpcError::Deser(
                    "decoding struct SignInResponse, expected array or map".to_string(),
                ))
            }
        };
        if is_array {
            let len = d.fixed_array()?;
            for __i in 0..(len as usize) {
                match __i {
                    0 => {
                        error = if wasmbus_rpc::cbor::Type::Null == d.datatype()? {
                            d.skip()?;
                            Some(None)
                        } else {
                            Some(Some( decode_surreal_db_error(d).map_err(|e| format!("decoding 'org.wasmcloud.interface.surrealdb#SurrealDbError': {}", e))? ))
                        }
                    }
                    1 => {
                        jwt = if wasmbus_rpc::cbor::Type::Null == d.datatype()? {
                            d.skip()?;
                            Some(None)
                        } else {
                            Some(Some(d.str()?.to_string()))
                        }
                    }
                    2 => success = Some(d.bool()?),
                    _ => d.skip()?,
                }
            }
        } else {
            let len = d.fixed_map()?;
            for __i in 0..(len as usize) {
                match d.str()? {
                    "error" => {
                        error = if wasmbus_rpc::cbor::Type::Null == d.datatype()? {
                            d.skip()?;
                            Some(None)
                        } else {
                            Some(Some( decode_surreal_db_error(d).map_err(|e| format!("decoding 'org.wasmcloud.interface.surrealdb#SurrealDbError': {}", e))? ))
                        }
                    }
                    "jwt" => {
                        jwt = if wasmbus_rpc::cbor::Type::Null == d.datatype()? {
                            d.skip()?;
                            Some(None)
                        } else {
                            Some(Some(d.str()?.to_string()))
                        }
                    }
                    "success" => success = Some(d.bool()?),
                    _ => d.skip()?,
                }
            }
        }
        SignInResponse {
            error: error.unwrap(),
            jwt: jwt.unwrap(),

            success: if let Some(__x) = success {
                __x
            } else {
                return Err(RpcError::Deser(
                    "missing field SignInResponse.success (#2)".to_string(),
                ));
            },
        }
    };
    Ok(__result)
}
#[derive(Clone, Debug, Default, Deserialize, Eq, PartialEq, Serialize)]
pub struct SignUpResponse {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub error: Option<SurrealDbError>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub jwt: Option<String>,
    #[serde(default)]
    pub success: bool,
}

// Encode SignUpResponse as CBOR and append to output stream
#[doc(hidden)]
#[allow(unused_mut)]
pub fn encode_sign_up_response<W: wasmbus_rpc::cbor::Write>(
    mut e: &mut wasmbus_rpc::cbor::Encoder<W>,
    val: &SignUpResponse,
) -> RpcResult<()>
where
    <W as wasmbus_rpc::cbor::Write>::Error: std::fmt::Display,
{
    e.map(3)?;
    if let Some(val) = val.error.as_ref() {
        e.str("error")?;
        encode_surreal_db_error(e, val)?;
    } else {
        e.null()?;
    }
    if let Some(val) = val.jwt.as_ref() {
        e.str("jwt")?;
        e.str(val)?;
    } else {
        e.null()?;
    }
    e.str("success")?;
    e.bool(val.success)?;
    Ok(())
}

// Decode SignUpResponse from cbor input stream
#[doc(hidden)]
pub fn decode_sign_up_response(
    d: &mut wasmbus_rpc::cbor::Decoder<'_>,
) -> Result<SignUpResponse, RpcError> {
    let __result = {
        let mut error: Option<Option<SurrealDbError>> = Some(None);
        let mut jwt: Option<Option<String>> = Some(None);
        let mut success: Option<bool> = None;

        let is_array = match d.datatype()? {
            wasmbus_rpc::cbor::Type::Array => true,
            wasmbus_rpc::cbor::Type::Map => false,
            _ => {
                return Err(RpcError::Deser(
                    "decoding struct SignUpResponse, expected array or map".to_string(),
                ))
            }
        };
        if is_array {
            let len = d.fixed_array()?;
            for __i in 0..(len as usize) {
                match __i {
                    0 => {
                        error = if wasmbus_rpc::cbor::Type::Null == d.datatype()? {
                            d.skip()?;
                            Some(None)
                        } else {
                            Some(Some( decode_surreal_db_error(d).map_err(|e| format!("decoding 'org.wasmcloud.interface.surrealdb#SurrealDbError': {}", e))? ))
                        }
                    }
                    1 => {
                        jwt = if wasmbus_rpc::cbor::Type::Null == d.datatype()? {
                            d.skip()?;
                            Some(None)
                        } else {
                            Some(Some(d.str()?.to_string()))
                        }
                    }
                    2 => success = Some(d.bool()?),
                    _ => d.skip()?,
                }
            }
        } else {
            let len = d.fixed_map()?;
            for __i in 0..(len as usize) {
                match d.str()? {
                    "error" => {
                        error = if wasmbus_rpc::cbor::Type::Null == d.datatype()? {
                            d.skip()?;
                            Some(None)
                        } else {
                            Some(Some( decode_surreal_db_error(d).map_err(|e| format!("decoding 'org.wasmcloud.interface.surrealdb#SurrealDbError': {}", e))? ))
                        }
                    }
                    "jwt" => {
                        jwt = if wasmbus_rpc::cbor::Type::Null == d.datatype()? {
                            d.skip()?;
                            Some(None)
                        } else {
                            Some(Some(d.str()?.to_string()))
                        }
                    }
                    "success" => success = Some(d.bool()?),
                    _ => d.skip()?,
                }
            }
        }
        SignUpResponse {
            error: error.unwrap(),
            jwt: jwt.unwrap(),

            success: if let Some(__x) = success {
                __x
            } else {
                return Err(RpcError::Deser(
                    "missing field SignUpResponse.success (#2)".to_string(),
                ));
            },
        }
    };
    Ok(__result)
}
#[derive(Clone, Debug, Default, Deserialize, Eq, PartialEq, Serialize)]
pub struct SurrealDbError {
    #[serde(default)]
    pub message: String,
    #[serde(default)]
    pub name: String,
}

// Encode SurrealDbError as CBOR and append to output stream
#[doc(hidden)]
#[allow(unused_mut)]
pub fn encode_surreal_db_error<W: wasmbus_rpc::cbor::Write>(
    mut e: &mut wasmbus_rpc::cbor::Encoder<W>,
    val: &SurrealDbError,
) -> RpcResult<()>
where
    <W as wasmbus_rpc::cbor::Write>::Error: std::fmt::Display,
{
    e.map(2)?;
    e.str("message")?;
    e.str(&val.message)?;
    e.str("name")?;
    e.str(&val.name)?;
    Ok(())
}

// Decode SurrealDbError from cbor input stream
#[doc(hidden)]
pub fn decode_surreal_db_error(
    d: &mut wasmbus_rpc::cbor::Decoder<'_>,
) -> Result<SurrealDbError, RpcError> {
    let __result = {
        let mut message: Option<String> = None;
        let mut name: Option<String> = None;

        let is_array = match d.datatype()? {
            wasmbus_rpc::cbor::Type::Array => true,
            wasmbus_rpc::cbor::Type::Map => false,
            _ => {
                return Err(RpcError::Deser(
                    "decoding struct SurrealDbError, expected array or map".to_string(),
                ))
            }
        };
        if is_array {
            let len = d.fixed_array()?;
            for __i in 0..(len as usize) {
                match __i {
                    0 => message = Some(d.str()?.to_string()),
                    1 => name = Some(d.str()?.to_string()),
                    _ => d.skip()?,
                }
            }
        } else {
            let len = d.fixed_map()?;
            for __i in 0..(len as usize) {
                match d.str()? {
                    "message" => message = Some(d.str()?.to_string()),
                    "name" => name = Some(d.str()?.to_string()),
                    _ => d.skip()?,
                }
            }
        }
        SurrealDbError {
            message: if let Some(__x) = message {
                __x
            } else {
                return Err(RpcError::Deser(
                    "missing field SurrealDbError.message (#0)".to_string(),
                ));
            },

            name: if let Some(__x) = name {
                __x
            } else {
                return Err(RpcError::Deser(
                    "missing field SurrealDbError.name (#1)".to_string(),
                ));
            },
        }
    };
    Ok(__result)
}
pub type SurrealDbErrors = Vec<SurrealDbError>;

// Encode SurrealDbErrors as CBOR and append to output stream
#[doc(hidden)]
#[allow(unused_mut)]
pub fn encode_surreal_db_errors<W: wasmbus_rpc::cbor::Write>(
    mut e: &mut wasmbus_rpc::cbor::Encoder<W>,
    val: &SurrealDbErrors,
) -> RpcResult<()>
where
    <W as wasmbus_rpc::cbor::Write>::Error: std::fmt::Display,
{
    e.array(val.len() as u64)?;
    for item in val.iter() {
        encode_surreal_db_error(e, item)?;
    }
    Ok(())
}

// Decode SurrealDbErrors from cbor input stream
#[doc(hidden)]
pub fn decode_surreal_db_errors(
    d: &mut wasmbus_rpc::cbor::Decoder<'_>,
) -> Result<SurrealDbErrors, RpcError> {
    let __result = {
        if let Some(n) = d.array()? {
            let mut arr: Vec<SurrealDbError> = Vec::with_capacity(n as usize);
            for _ in 0..(n as usize) {
                arr.push(decode_surreal_db_error(d).map_err(|e| {
                    format!(
                        "decoding 'org.wasmcloud.interface.surrealdb#SurrealDbError': {}",
                        e
                    )
                })?)
            }
            arr
        } else {
            // indefinite array
            let mut arr: Vec<SurrealDbError> = Vec::new();
            loop {
                match d.datatype() {
                    Err(_) => break,
                    Ok(wasmbus_rpc::cbor::Type::Break) => break,
                    Ok(_) => arr.push(decode_surreal_db_error(d).map_err(|e| {
                        format!(
                            "decoding 'org.wasmcloud.interface.surrealdb#SurrealDbError': {}",
                            e
                        )
                    })?),
                }
            }
            arr
        }
    };
    Ok(__result)
}
/// Interact with a SurrealDB instance
/// wasmbus.contractId: wasmcloud:surrealdb
/// wasmbus.providerReceive
#[async_trait]
pub trait SurrealDb {
    /// returns the capability contract id for this interface
    fn contract_id() -> &'static str {
        "wasmcloud:surrealdb"
    }
    /// Send a query to the SurrealDb instance.
    async fn query(&self, ctx: &Context, arg: &QueryRequest) -> RpcResult<QueryResponses>;
    /// Sign a new user up to an existing scope. If the scope has not been set up
    /// beforehand then this request will fail.
    ///
    /// It's recommended to set up password hashing when defining the sign_up/sign_in
    /// functions for a new scope:
    /// ```
    /// DEFINE SCOPE admin SESSION 1d
    /// SIGNUP ( CREATE user SET user = $user, pass = crypto::argon2::generate($pass) )
    /// SIGNIN ( SELECT * FROM user WHERE user = $user AND crypto::argon2::compare(pass, $pass));
    /// ```
    async fn sign_up(&self, ctx: &Context, arg: &Scope) -> RpcResult<SignUpResponse>;
    async fn sign_in(&self, ctx: &Context, arg: &Scope) -> RpcResult<SignInResponse>;
    async fn authenticate<TS: ToString + ?Sized + std::marker::Sync>(
        &self,
        ctx: &Context,
        arg: &TS,
    ) -> RpcResult<AuthenticateResponse>;
}

/// SurrealDbReceiver receives messages defined in the SurrealDb service trait
/// Interact with a SurrealDB instance
#[doc(hidden)]
#[async_trait]
pub trait SurrealDbReceiver: MessageDispatch + SurrealDb {
    async fn dispatch(&self, ctx: &Context, message: Message<'_>) -> Result<Vec<u8>, RpcError> {
        match message.method {
            "Query" => {
                let value: QueryRequest = wasmbus_rpc::common::deserialize(&message.arg)
                    .map_err(|e| RpcError::Deser(format!("'QueryRequest': {}", e)))?;

                let resp = SurrealDb::query(self, ctx, &value).await?;
                let buf = wasmbus_rpc::common::serialize(&resp)?;

                Ok(buf)
            }
            "SignUp" => {
                let value: Scope = wasmbus_rpc::common::deserialize(&message.arg)
                    .map_err(|e| RpcError::Deser(format!("'Scope': {}", e)))?;

                let resp = SurrealDb::sign_up(self, ctx, &value).await?;
                let buf = wasmbus_rpc::common::serialize(&resp)?;

                Ok(buf)
            }
            "SignIn" => {
                let value: Scope = wasmbus_rpc::common::deserialize(&message.arg)
                    .map_err(|e| RpcError::Deser(format!("'Scope': {}", e)))?;

                let resp = SurrealDb::sign_in(self, ctx, &value).await?;
                let buf = wasmbus_rpc::common::serialize(&resp)?;

                Ok(buf)
            }
            "Authenticate" => {
                let value: String = wasmbus_rpc::common::deserialize(&message.arg)
                    .map_err(|e| RpcError::Deser(format!("'String': {}", e)))?;

                let resp = SurrealDb::authenticate(self, ctx, &value).await?;
                let buf = wasmbus_rpc::common::serialize(&resp)?;

                Ok(buf)
            }
            _ => Err(RpcError::MethodNotHandled(format!(
                "SurrealDb::{}",
                message.method
            ))),
        }
    }
}

/// SurrealDbSender sends messages to a SurrealDb service
/// Interact with a SurrealDB instance
/// client for sending SurrealDb messages
#[derive(Clone, Debug)]
pub struct SurrealDbSender<T: Transport> {
    transport: T,
}

impl<T: Transport> SurrealDbSender<T> {
    /// Constructs a SurrealDbSender with the specified transport
    pub fn via(transport: T) -> Self {
        Self { transport }
    }

    pub fn set_timeout(&self, interval: std::time::Duration) {
        self.transport.set_timeout(interval);
    }
}

#[cfg(target_arch = "wasm32")]
impl SurrealDbSender<wasmbus_rpc::actor::prelude::WasmHost> {
    /// Constructs a client for sending to a SurrealDb provider
    /// implementing the 'wasmcloud:surrealdb' capability contract, with the "default" link
    pub fn new() -> Self {
        let transport =
            wasmbus_rpc::actor::prelude::WasmHost::to_provider("wasmcloud:surrealdb", "default")
                .unwrap();
        Self { transport }
    }

    /// Constructs a client for sending to a SurrealDb provider
    /// implementing the 'wasmcloud:surrealdb' capability contract, with the specified link name
    pub fn new_with_link(link_name: &str) -> wasmbus_rpc::error::RpcResult<Self> {
        let transport =
            wasmbus_rpc::actor::prelude::WasmHost::to_provider("wasmcloud:surrealdb", link_name)?;
        Ok(Self { transport })
    }
}
#[async_trait]
impl<T: Transport + std::marker::Sync + std::marker::Send> SurrealDb for SurrealDbSender<T> {
    #[allow(unused)]
    /// Send a query to the SurrealDb instance.
    async fn query(&self, ctx: &Context, arg: &QueryRequest) -> RpcResult<QueryResponses> {
        let buf = wasmbus_rpc::common::serialize(arg)?;

        let resp = self
            .transport
            .send(
                ctx,
                Message {
                    method: "SurrealDb.Query",
                    arg: Cow::Borrowed(&buf),
                },
                None,
            )
            .await?;

        let value: QueryResponses = wasmbus_rpc::common::deserialize(&resp)
            .map_err(|e| RpcError::Deser(format!("'{}': QueryResponses", e)))?;
        Ok(value)
    }
    #[allow(unused)]
    /// Sign a new user up to an existing scope. If the scope has not been set up
    /// beforehand then this request will fail.
    ///
    /// It's recommended to set up password hashing when defining the sign_up/sign_in
    /// functions for a new scope:
    /// ```
    /// DEFINE SCOPE admin SESSION 1d
    /// SIGNUP ( CREATE user SET user = $user, pass = crypto::argon2::generate($pass) )
    /// SIGNIN ( SELECT * FROM user WHERE user = $user AND crypto::argon2::compare(pass, $pass));
    /// ```
    async fn sign_up(&self, ctx: &Context, arg: &Scope) -> RpcResult<SignUpResponse> {
        let buf = wasmbus_rpc::common::serialize(arg)?;

        let resp = self
            .transport
            .send(
                ctx,
                Message {
                    method: "SurrealDb.SignUp",
                    arg: Cow::Borrowed(&buf),
                },
                None,
            )
            .await?;

        let value: SignUpResponse = wasmbus_rpc::common::deserialize(&resp)
            .map_err(|e| RpcError::Deser(format!("'{}': SignUpResponse", e)))?;
        Ok(value)
    }
    #[allow(unused)]
    async fn sign_in(&self, ctx: &Context, arg: &Scope) -> RpcResult<SignInResponse> {
        let buf = wasmbus_rpc::common::serialize(arg)?;

        let resp = self
            .transport
            .send(
                ctx,
                Message {
                    method: "SurrealDb.SignIn",
                    arg: Cow::Borrowed(&buf),
                },
                None,
            )
            .await?;

        let value: SignInResponse = wasmbus_rpc::common::deserialize(&resp)
            .map_err(|e| RpcError::Deser(format!("'{}': SignInResponse", e)))?;
        Ok(value)
    }
    #[allow(unused)]
    async fn authenticate<TS: ToString + ?Sized + std::marker::Sync>(
        &self,
        ctx: &Context,
        arg: &TS,
    ) -> RpcResult<AuthenticateResponse> {
        let buf = wasmbus_rpc::common::serialize(&arg.to_string())?;

        let resp = self
            .transport
            .send(
                ctx,
                Message {
                    method: "SurrealDb.Authenticate",
                    arg: Cow::Borrowed(&buf),
                },
                None,
            )
            .await?;

        let value: AuthenticateResponse = wasmbus_rpc::common::deserialize(&resp)
            .map_err(|e| RpcError::Deser(format!("'{}': AuthenticateResponse", e)))?;
        Ok(value)
    }
}
